分布式架构
优点：高并发、高可用、服务解耦
缺点：服务间调用复杂、数据一致、缓存一致、维护成本高

高并发
	服务拆分，docker多实例负载均衡
redis cache集群
	给DB减压，分布式服务的cache一致性，分布式锁
ELK集群
	快速查询引擎，给DB减压
kafka消息队列
	请求削峰、顺序消费、统一数据接口（数据总线）


分布式事务

===============redis================
1. cache更新
主动式更新：先删cache，加上分布式锁setnx防止击穿，设置ttl，接着update db，回填，解锁。加上事务。
被动式更新：key加上ttl，过期更新时加上setnx锁，设置 ttl，取db数据，回填




============jvm gc===========
jvm四大块：
	堆：对象实例，空间动态分配
	栈：引用、局部变量（基本类型）。特点是快、数据共享（int a=3; int b=3; a和b都指向一个3的地址）
	方法区：类信息、静态变量、常量
	本地方法栈：本地方法接口，和操作系统交互
===GC===
分代回收算法（复制算法 结合 标记整理算法）
如何确定回收：引用计数法、可达性分析法
青年代（Eden(80%)+两个Survivor区(20%)）：复制算法，把存活的复制到空的Survivor区，能晋升的到old区，其余清理
老年代：标记整理算法，该方法不直接对可回收对象进行清理，而是让所有可用的对象都向一端移动，然后直接清理掉边界外的对象，解决了标记清除算法带来的碎片化问题

青年代转老年代：
青年代对象在经过几次 Young GC 后，如果对象还存活着（默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定）；或者新建对象比较大，直接进入老年代（-XX:PretenureSizeThreshold=1024，表示超过多大时就不在年轻代分配）

Full GC 触发: 
	1. 当老年代满了的时候就需要对老年代进行垃圾回收，老年代的垃圾回收称作Full GC。老年代所占用的内存大小为-Xmx对应的值减去-Xmn对应的值。
	2. System.gc()
Young GC 触发:
	Eden区满时，存活的放到空的Survivor区；另一个Survivor区，存活的转Survivor区，满足条件的到old区，其余清空。每次GC后，总有一个Survivor是空的

调优：
-Xms=-Xmx,降低full gc 频率 （xms默认为内存的1/64, xmx为内存的1/4）
-Xmn，固定新生代区大小，降低Young GC频率 (默认jvm的1/3)


强引用：
回收：只有引用不会再被使用时，否则无法回收（即使内存不足触发GC，或者执行System.gc()）
软引用：
回收：当内存不足时
弱引用：
回收：不论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收


秒杀，防止超卖
redis中加入list队列，队列中存放商品ID
利用pop操作的原子性，防止出现超卖
pop成功，给用户下单，提示用户抢购成功，否则提示抢购失败

如果用户抢购成功，但后来取消了订单，商品ID重新加入队列

数据库，用户在支付后更新库存数量，库存在更新时加锁，防止库存数量出现0-1,使用select for update，and count > 0



=============
基于k8s容器技术的分布式应用，采用的openshift ecs，实现了服务路由、负载均衡、熔断、横向扩展，服务管理中心页面，涉及的中间件（ELK，Redis，Kafka）

服务之间的调用：通过http请求容器的router，每个service在openshift ecs里有个对外的router，router对应一个域名，所有请求访问域名地址，然后再转发到router对应的容器实例IP，通过router路由实现了负载均衡









